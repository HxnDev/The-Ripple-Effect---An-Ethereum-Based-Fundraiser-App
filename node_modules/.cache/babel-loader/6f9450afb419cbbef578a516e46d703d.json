{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar rlp = __importStar(require(\"rlp\"));\n\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nvar internal_1 = require(\"./internal\");\n\nvar constants_1 = require(\"./constants\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar types_1 = require(\"./types\");\n\nvar Account =\n/** @class */\nfunction () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new bn_js_1.default(0);\n    }\n\n    if (balance === void 0) {\n      balance = new bn_js_1.default(0);\n    }\n\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n        balance = accountData.balance,\n        stateRoot = accountData.stateRoot,\n        codeHash = accountData.codeHash;\n    return new Account(nonce ? new bn_js_1.default((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new bn_js_1.default((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  };\n\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = rlp.decode(serialized);\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  };\n\n  Account.fromValuesArray = function (values) {\n    var _a = __read(values, 4),\n        nonce = _a[0],\n        balance = _a[1],\n        stateRoot = _a[2],\n        codeHash = _a[3];\n\n    return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\n  };\n\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new bn_js_1.default(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance.lt(new bn_js_1.default(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n\n\n  Account.prototype.raw = function () {\n    return [(0, types_1.bnToUnpaddedBuffer)(this.nonce), (0, types_1.bnToUnpaddedBuffer)(this.balance), this.stateRoot, this.codeHash];\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  Account.prototype.serialize = function () {\n    return rlp.encode(this.raw());\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n\n\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n\n  return Account;\n}();\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nvar isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\n\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  var prefix = '';\n\n  if (eip1191ChainId) {\n    var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n    prefix = chainId.toString() + '0x';\n  }\n\n  var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\n\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\nvar generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n  var nonceBN = new bn_js_1.default(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return (0, hash_1.rlphash)([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\nvar generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n  (0, assert_1.default)(from.length === 20);\n  (0, assert_1.default)(salt.length === 32);\n  var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\n  return address.slice(-20);\n};\n\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\nvar isValidPrivate = function (privateKey) {\n  return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\n\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nvar isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\n\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nvar pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  (0, helpers_1.assertIsBuffer)(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n  }\n\n  (0, assert_1.default)(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return (0, hash_1.keccak)(pubKey).slice(-20);\n};\n\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nvar privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\n\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nvar privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\n\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\n\nvar importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\n\nvar zeroAddress = function () {\n  var addressLength = 20;\n  var addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\n\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\n\nvar isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  var zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\n\nexports.isZeroAddress = isZeroAddress;","map":{"version":3,"sources":["D:\\react\\test\\node_modules\\ethereumjs-util\\src\\account.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'assert'\nimport BN from 'bn.js'\nimport * as rlp from 'rlp'\nimport {\n  privateKeyVerify,\n  publicKeyCreate,\n  publicKeyVerify,\n  publicKeyConvert,\n} from 'ethereum-cryptography/secp256k1'\nimport { stripHexPrefix } from './internal'\nimport { KECCAK256_RLP, KECCAK256_NULL } from './constants'\nimport { zeros, bufferToHex, toBuffer } from './bytes'\nimport { keccak, keccak256, keccakFromString, rlphash } from './hash'\nimport { assertIsString, assertIsHexString, assertIsBuffer } from './helpers'\nimport { BNLike, BufferLike, bnToUnpaddedBuffer, toType, TypeOutput } from './types'\n\nexport interface AccountData {\n  nonce?: BNLike\n  balance?: BNLike\n  stateRoot?: BufferLike\n  codeHash?: BufferLike\n}\n\nexport class Account {\n  nonce: BN\n  balance: BN\n  stateRoot: Buffer\n  codeHash: Buffer\n\n  static fromAccountData(accountData: AccountData) {\n    const { nonce, balance, stateRoot, codeHash } = accountData\n\n    return new Account(\n      nonce ? new BN(toBuffer(nonce)) : undefined,\n      balance ? new BN(toBuffer(balance)) : undefined,\n      stateRoot ? toBuffer(stateRoot) : undefined,\n      codeHash ? toBuffer(codeHash) : undefined\n    )\n  }\n\n  public static fromRlpSerializedAccount(serialized: Buffer) {\n    const values = rlp.decode(serialized)\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    return this.fromValuesArray(values)\n  }\n\n  public static fromValuesArray(values: Buffer[]) {\n    const [nonce, balance, stateRoot, codeHash] = values\n\n    return new Account(new BN(nonce), new BN(balance), stateRoot, codeHash)\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(\n    nonce = new BN(0),\n    balance = new BN(0),\n    stateRoot = KECCAK256_RLP,\n    codeHash = KECCAK256_NULL\n  ) {\n    this.nonce = nonce\n    this.balance = balance\n    this.stateRoot = stateRoot\n    this.codeHash = codeHash\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this.nonce.lt(new BN(0))) {\n      throw new Error('nonce must be greater than zero')\n    }\n    if (this.balance.lt(new BN(0))) {\n      throw new Error('balance must be greater than zero')\n    }\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32')\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32')\n    }\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  raw(): Buffer[] {\n    return [\n      bnToUnpaddedBuffer(this.nonce),\n      bnToUnpaddedBuffer(this.balance),\n      this.stateRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  serialize(): Buffer {\n    return rlp.encode(this.raw())\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    return !this.codeHash.equals(KECCAK256_NULL)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(KECCAK256_NULL)\n  }\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (hexAddress: string, eip1191ChainId?: BNLike): string {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId) {\n    const chainId = toType(eip1191ChainId, TypeOutput.BN)\n    prefix = chainId.toString() + '0x'\n  }\n\n  const hash = keccakFromString(prefix + address).toString('hex')\n  let ret = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return ret\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BNLike\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Buffer, nonce: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(nonce)\n  const nonceBN = new BN(nonce)\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return rlphash([from, null]).slice(-20)\n  }\n\n  // Only take the lower 160bits of the hash\n  return rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from: Buffer, salt: Buffer, initCode: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(salt)\n  assertIsBuffer(initCode)\n\n  assert(from.length === 20)\n  assert(salt.length === 32)\n\n  const address = keccak256(\n    Buffer.concat([Buffer.from('ff', 'hex'), from, salt, keccak256(initCode)])\n  )\n\n  return address.slice(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Buffer): boolean {\n  return privateKeyVerify(privateKey)\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Buffer, sanitize: boolean = false): boolean {\n  assertIsBuffer(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]))\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  return publicKeyVerify(publicKey)\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Buffer, sanitize: boolean = false): Buffer {\n  assertIsBuffer(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1))\n  }\n  assert(pubKey.length === 64)\n  // Only take the lower 160bits of the hash\n  return keccak(pubKey).slice(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Buffer): Buffer {\n  assertIsBuffer(privateKey)\n  // skip the type flag and use the X, Y points\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1)\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Buffer): Buffer {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Buffer): Buffer {\n  assertIsBuffer(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1))\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): string {\n  const addressLength = 20\n  const addr = zeros(addressLength)\n  return bufferToHex(addr)\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n"]},"metadata":{},"sourceType":"script"}